declare const _default: "uniform sampler2D aoBuffer;\nuniform float luminanceInfluence;\n\n#ifdef DEPTH_AWARE_UPSAMPLING\n\n\t#ifdef GL_FRAGMENT_PRECISION_HIGH\n\n\t\tuniform highp sampler2D normalDepthBuffer;\n\n\t#else\n\n\t\tuniform mediump sampler2D normalDepthBuffer;\n\n\t#endif\n\n#endif\n\n#ifdef COLORIZE\n\n\tuniform vec3 color;\n\n#endif\n\nvoid mainImage(const in vec4 inputColor, const in vec2 uv, const in float depth, out vec4 outputColor) {\n\n\tfloat aoLinear = texture2D(aoBuffer, uv).r;\n\n\t#if defined(DEPTH_AWARE_UPSAMPLING) && __VERSION__ == 300\n\n\t\t// Gather normals and depth in a 2x2 neighborhood.\n\t\tvec4 normalDepth[4] = vec4[](\n\t\t\ttextureOffset(normalDepthBuffer, uv, ivec2(0, 0)),\n\t\t\ttextureOffset(normalDepthBuffer, uv, ivec2(0, 1)),\n\t\t\ttextureOffset(normalDepthBuffer, uv, ivec2(1, 0)),\n\t\t\ttextureOffset(normalDepthBuffer, uv, ivec2(1, 1))\n\t\t);\n\n\t\t// Determine the smoothness of the surface around this fragment.\n\t\tfloat dot01 = dot(normalDepth[0].rgb, normalDepth[1].rgb);\n\t\tfloat dot02 = dot(normalDepth[0].rgb, normalDepth[2].rgb);\n\t\tfloat dot03 = dot(normalDepth[0].rgb, normalDepth[3].rgb);\n\n\t\tfloat minDot = min(dot01, min(dot02, dot03));\n\t\tfloat s = step(THRESHOLD, minDot);\n\n\t\t// Find the best AO based on depth.\n\t\tfloat smallestDistance = 1.0;\n\t\tint index;\n\n\t\tfor(int i = 0; i < 4; ++i) {\n\n\t\t\tfloat distance = abs(depth - normalDepth[i].a);\n\n\t\t\tif(distance < smallestDistance) {\n\n\t\t\t\tsmallestDistance = distance;\n\t\t\t\tindex = i;\n\n\t\t\t}\n\n\t\t}\n \n\t\t// Fetch the exact AO texel that corresponds to the best depth.\n\t\tivec2 offsets[4] = ivec2[](\n\t\t\tivec2(0, 0), ivec2(0, 1),\n\t\t\tivec2(1, 0), ivec2(1, 1)\n\t\t);\n\n\t\tivec2 coord = ivec2(uv * vec2(textureSize(aoBuffer, 0))) + offsets[index];\n\t\tfloat aoNearest = texelFetch(aoBuffer, coord, 0).r;\n\n\t\t// Smooth surfaces benefit more from linear filtering.\n\t\tfloat ao = mix(aoNearest, aoLinear, s);\n\n\t#else\n\n\t\tfloat ao = aoLinear;\n\n\t#endif\n\n\t// Fade AO based on luminance.\n\tfloat l = linearToRelativeLuminance(inputColor.rgb);\n\tao = mix(ao, 1.0, l * luminanceInfluence);\n\n\t#ifdef COLORIZE\n\n\t\toutputColor = vec4(1.0 - (1.0 - ao) * (1.0 - color), inputColor.a);\n\n\t#else\n\n\t\toutputColor = vec4(vec3(ao), inputColor.a);\n\n\t#endif\n\n}\n";
export default _default;
