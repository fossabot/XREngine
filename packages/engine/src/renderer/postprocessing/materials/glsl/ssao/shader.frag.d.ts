declare const _default: "#include <common>\n#include <packing>\n\n#ifdef GL_FRAGMENT_PRECISION_HIGH\n\n\tuniform highp sampler2D normalDepthBuffer;\n\n#else\n\n\tuniform mediump sampler2D normalDepthBuffer;\n\n#endif\n\n#ifndef NORMAL_DEPTH\n\n\tuniform sampler2D normalBuffer;\n\n\t// The depth texture is bound to normalDepthBuffer.\n\tfloat readDepth(const in vec2 uv) {\n\n\t\t#if DEPTH_PACKING == 3201\n\n\t\t\treturn unpackRGBAToDepth(texture2D(normalDepthBuffer, uv));\n\n\t\t#else\n\n\t\t\treturn texture2D(normalDepthBuffer, uv).r;\n\n\t\t#endif\n\n\t}\n\n#endif\n\nuniform sampler2D noiseTexture;\n\nuniform mat4 inverseProjectionMatrix;\nuniform mat4 projectionMatrix;\nuniform vec2 texelSize;\n\nuniform float cameraNear;\nuniform float cameraFar;\nuniform float minRadiusScale;\nuniform float intensity;\nuniform float fade;\nuniform float bias;\n\nuniform vec2 distanceCutoff;\nuniform vec2 proximityCutoff;\n\nvarying vec2 vUv;\nvarying vec2 vUv2;\n\nfloat getViewZ(const in float depth) {\n\n\t#ifdef PERSPECTIVE_CAMERA\n\n\t\treturn perspectiveDepthToViewZ(depth, cameraNear, cameraFar);\n\n\t#else\n\n\t\treturn orthographicDepthToViewZ(depth, cameraNear, cameraFar);\n\n\t#endif\n\n}\n\nvec3 getViewPosition(const in vec2 screenPosition, const in float depth, const in float viewZ) {\n\n\tfloat clipW = projectionMatrix[2][3] * viewZ + projectionMatrix[3][3];\n\tvec4 clipPosition = vec4((vec3(screenPosition, depth) - 0.5) * 2.0, 1.0);\n\tclipPosition *= clipW; // Unproject.\n\n\treturn (inverseProjectionMatrix * clipPosition).xyz;\n\n}\n\nfloat getAmbientOcclusion(const in vec3 p, const in vec3 n, const in float depth, const in vec2 uv) {\n\n\t#ifdef DISTANCE_SCALING\n\n\t\tfloat radiusScale = 1.0 - smoothstep(0.0, distanceCutoff.y, depth);\n\t\tradiusScale = radiusScale * (1.0 - minRadiusScale) + minRadiusScale;\n\n\t\tfloat radius = RADIUS * radiusScale;\n\n\t#else\n\n\t\tfloat radius = RADIUS;\n\n\t#endif\n\n\t// Use a random starting angle.\n\tfloat noise = texture2D(noiseTexture, vUv2).r;\n\tfloat baseAngle = noise * PI2;\n\n\tfloat inv_samples = 1.0 / SAMPLES_FLOAT;\n\tfloat rings = SPIRAL_TURNS * PI2;\n\n\tfloat occlusion = 0.0;\n\tint taps = 0;\n\n\tfor(int i = 0; i < SAMPLES_INT; ++i) {\n\n\t\tfloat alpha = (float(i) + 0.5) * inv_samples;\n\t\tfloat angle = alpha * rings + baseAngle;\n\n\t\tvec2 coord = alpha * radius * vec2(cos(angle), sin(angle)) * texelSize + uv;\n\n\t\tif(coord.s < 0.0 || coord.s > 1.0 || coord.t < 0.0 || coord.t > 1.0) {\n\n\t\t\t// Skip samples outside the screen.\n\t\t\tcontinue;\n\n\t\t}\n\n\t\t#ifdef NORMAL_DEPTH\n\n\t\t\tfloat sampleDepth = texture2D(normalDepthBuffer, coord).a;\n\n\t\t#else\n\n\t\t\tfloat sampleDepth = readDepth(coord);\n\n\t\t#endif\n\n\t\tfloat viewZ = getViewZ(sampleDepth);\n\n\t\t#ifdef PERSPECTIVE_CAMERA\n\n\t\t\tfloat linearSampleDepth = viewZToOrthographicDepth(viewZ, cameraNear, cameraFar);\n\n\t\t#else\n\n\t\t\tfloat linearSampleDepth = sampleDepth;\n\n\t\t#endif\n\n\t\tfloat proximity = abs(depth - linearSampleDepth);\n\n\t\tif(proximity < proximityCutoff.y) {\n\n\t\t\tfloat falloff = 1.0 - smoothstep(proximityCutoff.x, proximityCutoff.y, proximity);\n\n\t\t\tvec3 Q = getViewPosition(coord, sampleDepth, viewZ);\n\t\t\tvec3 v = Q - p;\n\n\t\t\tfloat vv = dot(v, v);\n\t\t\tfloat vn = dot(v, n) - bias;\n\n\t\t\tfloat f = max(RADIUS_SQ - vv, 0.0) / RADIUS_SQ;\n\t\t\tocclusion += (f * f * f * max(vn / (fade + vv), 0.0)) * falloff;\n\n\t\t}\n\n\t\t++taps;\n\n\t}\n\n\treturn occlusion / (4.0 * max(float(taps), 1.0));\n\n}\n\nvoid main() {\n\n\t#ifdef NORMAL_DEPTH\n\n\t\tvec4 normalDepth = texture2D(normalDepthBuffer, vUv);\n\n\t#else\n\n\t\tvec4 normalDepth = vec4(\n\t\t\ttexture2D(normalBuffer, vUv).rgb,\n\t\t\treadDepth(vUv)\n\t\t);\n\n\t#endif\n\n\tfloat ao = 1.0;\n\tfloat depth = normalDepth.a;\n\tfloat viewZ = getViewZ(depth);\n\n\t#ifdef PERSPECTIVE_CAMERA\n\n\t\tfloat linearDepth = viewZToOrthographicDepth(viewZ, cameraNear, cameraFar);\n\n\t#else\n\n\t\tfloat linearDepth = depth;\n\n\t#endif\n\n\t// Skip fragments that are too far away.\n\tif(linearDepth < distanceCutoff.y) {\n\n\t\tvec3 viewPosition = getViewPosition(vUv, depth, viewZ);\n\t\tvec3 viewNormal = unpackRGBToNormal(normalDepth.rgb);\n\t\tao -= getAmbientOcclusion(viewPosition, viewNormal, linearDepth, vUv);\n\n\t\t// Fade AO based on depth.\n\t\tfloat d = smoothstep(distanceCutoff.x, distanceCutoff.y, linearDepth);\n\t\tao = mix(ao, 1.0, d);\n\n\t\t// Adjust the overall intensity.\n\t\tao = clamp(pow(ao, abs(intensity)), 0.0, 1.0);\n\n\t}\n\n\tgl_FragColor.r = ao;\n\n}\n";
export default _default;
