declare const _default: "#include <packing>\n\n#ifdef GL_FRAGMENT_PRECISION_HIGH\n\n\tuniform highp sampler2D depthBuffer;\n\n#else\n\n\tuniform mediump sampler2D depthBuffer;\n\n#endif\n\n#ifdef DOWNSAMPLE_NORMALS\n\n\tuniform sampler2D normalBuffer;\n\n#endif\n\nvarying vec2 vUv0;\nvarying vec2 vUv1;\nvarying vec2 vUv2;\nvarying vec2 vUv3;\n\nfloat readDepth(const in vec2 uv) {\n\n\t#if DEPTH_PACKING == 3201\n\n\t\treturn unpackRGBAToDepth(texture2D(depthBuffer, uv));\n\n\t#else\n\n\t\treturn texture2D(depthBuffer, uv).r;\n\n\t#endif\n\n}\n\n/**\n * Returns the index of the most representative depth in the 2x2 neighborhood.\n */\n\nint findBestDepth(const in float samples[4]) {\n\n\t// Calculate the centroid.\n\tfloat c = (samples[0] + samples[1] + samples[2] + samples[3]) / 4.0;\n\n\tfloat distances[4] = float[](\n\t\tabs(c - samples[0]), abs(c - samples[1]),\n\t\tabs(c - samples[2]), abs(c - samples[3])\n\t);\n\n\tfloat maxDistance = max(\n\t\tmax(distances[0], distances[1]),\n\t\tmax(distances[2], distances[3])\n\t);\n\n\tint remaining[3];\n\tint rejected[3];\n\n\tint i, j, k;\n\n\tfor(i = 0, j = 0, k = 0; i < 4; ++i) {\n\n\t\tif(distances[i] < maxDistance) {\n\n\t\t\t// Keep the most representative samples.\n\t\t\tremaining[j++] = i;\n\n\t\t} else {\n\n\t\t\t// Discard max distance samples.\n\t\t\trejected[k++] = i;\n\n\t\t}\n\n\t}\n\n\t// Fill up the array in case there were two or more max distance samples.\n\tfor(; j < 3; ++j) {\n\n\t\tremaining[j] = rejected[--k];\n\n\t}\n\n\t// Final candidates.\n\tvec3 s = vec3(\n\t\tsamples[remaining[0]],\n\t\tsamples[remaining[1]],\n\t\tsamples[remaining[2]]\n\t);\n\n\t// Recalculate the controid.\n\tc = (s.x + s.y + s.z) / 3.0;\n\n\tdistances[0] = abs(c - s.x);\n\tdistances[1] = abs(c - s.y);\n\tdistances[2] = abs(c - s.z);\n\n\tfloat minDistance = min(distances[0], min(distances[1], distances[2]));\n\n\t// Determine the index of the min distance sample.\n\tfor(i = 0; i < 3; ++i) {\n\n\t\tif(distances[i] == minDistance) {\n\n\t\t\tbreak;\n\n\t\t}\n\n\t}\n\n\treturn remaining[i];\n\n}\n\nvoid main() {\n\n\t// Gather depth samples in a 2x2 neighborhood.\n\tfloat d[4] = float[](\n\t\treadDepth(vUv0), readDepth(vUv1),\n\t\treadDepth(vUv2), readDepth(vUv3)\n\t);\n\n\tint index = findBestDepth(d);\n\n\t#ifdef DOWNSAMPLE_NORMALS\n\n\t\tvec2 uvs[4] = vec2[](vUv0, vUv1, vUv2, vUv3);\n\t\tvec3 n = texture2D(normalBuffer, uvs[index]).rgb;\n\n\t#else\n\n\t\tvec3 n = vec3(0.0);\n\n\t#endif\n\n\tgl_FragColor = vec4(n, d[index]);\n\n}\n";
export default _default;
