{"ast":null,"code":"var __jsx = React.createElement;\nimport React from 'react';\nimport { sampleUserData } from '../../utils/sample-data';\nimport Layout from '../../components/ui/Layout';\nimport ListDetail from '../../components/ui/ListDetail';\nexport default class StaticPropsDetail extends React.Component {\n  render() {\n    const {\n      item,\n      errors\n    } = this.props;\n\n    if (errors) {\n      return __jsx(Layout, {\n        title: `Error | Next.js + TypeScript Example`\n      }, __jsx(\"p\", null, __jsx(\"span\", {\n        style: {\n          color: 'red'\n        }\n      }, \"Error:\"), \" \", errors));\n    }\n\n    return __jsx(Layout, {\n      title: `${item ? item.name : 'User Detail'} | Next.js + TypeScript Example`\n    }, item && __jsx(ListDetail, {\n      item: item\n    }));\n  }\n\n}\nexport const getStaticPaths = async () => {\n  // Get the paths we want to pre-render based on users\n  const paths = sampleUserData.map(user => ({\n    params: {\n      id: user.id.toString()\n    }\n  })); // We'll pre-render only these paths at build time.\n  // { fallback: false } means other routes should 404.\n\n  return {\n    paths,\n    fallback: false\n  };\n}; // This function gets called at build time on server-side.\n// It won't be called on client-side, so you can even do\n// direct database queries.\n\nexport const getStaticProps = async ({\n  params\n}) => {\n  try {\n    const id = params === null || params === void 0 ? void 0 : params.id;\n    const item = sampleUserData.find(data => data.id === Number(id)); // By returning { props: item }, the StaticPropsDetail component\n    // will receive `item` as a prop at build time\n\n    return {\n      props: {\n        item\n      }\n    };\n  } catch (err) {\n    return {\n      props: {\n        errors: err.message\n      }\n    };\n  }\n};","map":null,"metadata":{},"sourceType":"module"}