import Message from "../interfaces/Message";
import DataAudioVideoTransport from "../interfaces/DataAudioVideoTransport";
export default class SocketWebRTCTransport implements DataAudioVideoTransport {
    stopCamera(): Promise<boolean>;
    stopScreenshare(): Promise<boolean>;
    startAudio(): boolean;
    stopAudio(): boolean;
    joinMediaRoom(roomId: string | number): boolean;
    leaveMediaRoom(): void;
    muteUser(userId: number): void;
    unmuteUser(userId: number): void;
    deinitialize(deinitializationCallback?: any): boolean;
    getAllMessages: import("../interfaces/Message").default[];
    addMessageToQueue(message: Message): boolean;
    sendAllMessages(): void;
    mediasoupDevice: any;
    joined: any;
    localCam: any;
    localScreen: any;
    recvTransport: any;
    sendTransport: any;
    camVideoProducer: any;
    camAudioProducer: any;
    screenVideoProducer: any;
    screenAudioProducer: any;
    lastPollSyncData: {};
    consumers: any[];
    pollingInterval: any;
    screenShareVideoPaused: boolean;
    screenShareAudioPaused: boolean;
    initialized: boolean;
    initialize(initializationCallback: any): boolean;
    private init;
    initSocketConnection(): Promise<unknown>;
    removeClientDOMElements(_id: any): void;
    joinRoom(): Promise<void>;
    sendCameraStreams(): Promise<void>;
    startScreenshare(): Promise<boolean>;
    startCamera(): Promise<boolean>;
    cycleCamera(): Promise<boolean>;
    stopSendingMediaStreams(): Promise<boolean>;
    leaveRoom(): Promise<boolean>;
    subscribeToTrack(peerId: any, mediaTag: any): Promise<void>;
    unsubscribeFromTrack(peerId: any, mediaTag: any): Promise<void>;
    pauseConsumer(consumer: any): Promise<void>;
    resumeConsumer(consumer: any): Promise<void>;
    pauseProducer(producer: any): Promise<void>;
    resumeProducer(producer: any): Promise<void>;
    closeConsumer(consumer: any): Promise<void>;
    createTransport(direction: any): Promise<any>;
    pollAndUpdate(): Promise<void>;
    findConsumerForTrack(peerId: any, mediaTag: any): any;
    getScreenPausedState(): boolean;
    getScreenAudioPausedState(): boolean;
    toggleWebcamVideoPauseState(): Promise<void>;
    toggleWebcamAudioPauseState(): Promise<void>;
    toggleScreenshareVideoPauseState(): Promise<void>;
    toggleScreenshareAudioPauseState(): Promise<void>;
    addVideoAudio(consumer: any, peerId: any): void;
    removeVideoAudio(consumer: any): void;
    getCurrentDeviceId(): Promise<any>;
    CAM_VIDEO_SIMULCAST_ENCODINGS: {
        maxBitrate: number;
        scaleResolutionDownBy: number;
    }[];
    camEncodings(): {
        maxBitrate: number;
        scaleResolutionDownBy: number;
    }[];
    screenshareEncodings(): void;
    sleep(ms: any): Promise<unknown>;
}
